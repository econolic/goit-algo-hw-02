def check_delimiters(s: str) -> tuple[str, str]:
    """
    Перевіряє симетричність розділювачів у рядку та підсвічує непарні.

    Args:
        s: Рядок, що містить символи-розділювачі та інші символи.

    Returns:
        Кортеж (статус, рядок_з_підсвічуванням):
        - статус: "Симетрично" або "Несиметрично".
        - рядок_з_підсвічуванням: рядок, де непарні розділювачі підсвічені.
    """
    stack = []  # Стек для зберігання кортежів (символ, індекс)
    # Словник для зіставлення відкриваючих та закриваючих дужок
    mapping = {")": "(", "}": "{", "]": "["}
    opening_brackets = {"(", "{", "["}
    closing_brackets = {")", "}", "]"}

    # ANSI escape коди для кольорів
    RED = "\033[91m"  # Червоний колір
    RESET = "\033[0m" # Скидання кольору

    # Перетворюємо рядок на список символів для легшої модифікації
    output_chars = list(s)

    # Перший прохід: шукаємо помилки з закриваючими розділювачами
    for index, char in enumerate(s):
        if char in opening_brackets:
            stack.append((char, index))  # Зберігаємо символ та його індекс
        elif char in closing_brackets:
            if not stack:
                # Знайдемо закриваючий розділювач без відповідного відкриваючого
                output_chars[index] = f"{RED}{char}{RESET}"
                return "Несиметрично", "".join(output_chars)
            
            # Отримуємо очікуваний відкриваючий розділювач для поточного закриваючого
            expected_opener = mapping[char]
            # Вилучаємо останній відкриваючий розділювач зі стеку
            actual_opener_char, actual_opener_index = stack.pop()

            if actual_opener_char != expected_opener:
                # Типи розділювачів не збігаються (наприклад, '(' та ']')
                output_chars[index] = f"{RED}{char}{RESET}"
                # Підсвітимо відповідний, але невірний, відкриваючий розділювач
                output_chars[actual_opener_index] = f"{RED}{actual_opener_char}{RESET}"
                return "Несиметрично", "".join(output_chars)

    # Другий прохід: якщо в стеку залишилися відкриваючі розділювачі, вони непарні
    if stack:
        for opener_char, opener_index in stack:
            output_chars[opener_index] = f"{RED}{opener_char}{RESET}"
        return "Несиметрично", "".join(output_chars)

    # Якщо помилок не знайдено і стек порожній
    return "Симетрично", s

if __name__ == "__main__":
    print("Тестові випадки:")
    test_cases = [
        ("( ){[ 1 ]( 1 + 3 )( ){ }}"), # Правильна симетрія
        ("( 23 ( 2 - 3);"), # Неправильна симетрія
        ("( 11 }"), # Неправильна симетрія
        ("()"), # Правильна симетрія
        ("()[]{}"), # Правильна симетрія
        ("([{}])"), # Правильна симетрія
        ("((()))"), # Правильна симетрія
        ("{[]}"), # Правильна симетрія
        ("("), # Неправильна симетрія
        (")"), # Неправильна симетрія
        ("(()"), # Неправильна симетрія
        ("())"), # Неправильна симетрія
        ("([)]"), # Неправильна симетрія
        ("{[}]"), # Неправильна симетрія
        ("abc"), # Немає розділювачів
        (""), # Порожній рядок
        ("text (with [some] delimiters) and {more text}"), # Правильна симетрія
        ("text (with [some) delimiters]"), # Неправильна симетрія
        (")))((("), # Неправильна симетрія
        ("{[()]}"), # Правильна симетрія
        ("{[(])}"), # Неправильна симетрія
        ("{{{{}}}}"), # Багаторазове вкладення
        ("{{{{}}}}}"), # Зайвий закриваючий розділювач
        ("{[}"), # Неправильна симетрія
        ("{[()]"), # Відкритий розділювач
        ("{[()]}{}"), # Правильна симетрія з кількома парами
    ]

    for test_str in test_cases:
        test, asym_test_str = check_delimiters(test_str)
        if test == "Несиметрично":
            print(f"'{asym_test_str}': {test}")
        else:
            print(f"'{test_str}': {test}")
